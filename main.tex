\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} % L'encodage du document
\usepackage[french]{babel} % Des options supplémentaires pour que le document soit en français (noms de sections, etc.)
\usepackage{geometry}
\geometry{hscale=0.80,vscale=0.80,centering} % Permet de définir les marges (ici 10% de chaque côté)
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm} % For theorem-like environments
\usepackage{graphicx} % Ajout du package graphicx
\usepackage{minted}
\usepackage{fixltx2e}
\usepackage{array}
\usepackage{lettrine}
\usepackage{tikz}
\usepackage[ruled,linesnumbered,french,onelanguage]{algorithm2e}
\usepackage{algpseudocode}
\usetikzlibrary{angles,quotes}

\newcolumntype{C}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}m{#1}}
\newcolumntype{N}{@{}m{0pt}@{}}

\newcounter{definitioncounter}
\renewcommand{\thedefinitioncounter}{\arabic{definitioncounter}}

\newcommand{\definition}[1]{%
    \par\noindent\textbf{Définition \refstepcounter{definitioncounter}\thedefinitioncounter.} #1 \vspace{0.5\baselineskip}
}

\newcommand{\fig}[1]{
    F\resizebox{!}{1.3ex}{IGURE} #1
}

\newcounter{propositioncounter}
\renewcommand{\thepropositioncounter}{\arabic{propositioncounter}}

\newcommand{\proposition}[1]{%
    \par\noindent\textbf{Proposition \refstepcounter{propositioncounter}\thepropositioncounter.} #1 \vspace{0.5\baselineskip}
}

\setlength{\parindent}{15pt} % Fixe l'indentation en début de paragraphe
\setlength{\parskip}{10pt} % Fixe l'espacement entre paragraphes

\begin{document}
\title{Simuler les feux de forêt}
\date{\today}
\author{Victor Sarrazin}

\maketitle

\section*{Introduction}

Avec le changement climatique, les feux de forêt sont de plus en plus fréquents et dévastateurs, à l'image de ceux en Californie en janvier 2025.

Dans ce cadre, les modélisations informatiques des feux de forêt permettent de simuler leur évolution et ainsi de prévoir les zones à risque. Elles offrent également la possibilité de tester l'impact de certaines transformations sur ces incendies, afin d'identifier des moyens de réduire les conséquences des catastrophes sans dénaturer les forêts.

\section{Automates cellulaires}

Pour réaliser nos modélisations, nous allons utiliser des automates cellulaires. Ces outils permettent de représenter des systèmes avec des interactions locales entre les éléments qui les constituent. Les automates cellulaires ont notamment été popularisés avec \textit{Le~Jeu~de~la~Vie} de \textit{Conway}.

\definition{Un automate cellulaire est la donnée d'un triplet $(Q, M, f)$ avec :\begin{itemize}
    \item $Q$ un ensemble d'états
    \item $M$ une matrice de taille $n \times m$, où chaque $m_{i,j}$ représente une cellule de la grille
    \item $f : \mathcal{M}_{n,m}(Q) \longrightarrow \mathcal{M}_{n,m}(Q)$ une \textit{fonction de transition} qui à une grille renvoie la grille suivante
\end{itemize}}

La définition de la fonction de transition dépend donc du type de voisinage considéré. Il existe deux principaux types de voisinages : celui de \textit{von Neumann} et celui de \textit{Moore}. Nous avons choisi d'utiliser le voisinage de \textit{Moore} pour nos modélisations pour prendre en compte le plus d'intéractions possibles, celui de \textit{von Neumann} étant plus limitatif, notamment en ce qui concerne les interactions diagonales.

\definition{Le voisinage de \textit{Moore} est composé de la cellule centrale et de ses 8 voisins adjacents (horizontalement, verticalement et diagonalement).}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.20\linewidth]{pictures/moore.png}
    \caption{Voisinage de Moore}
    \label{fig:enter-label}
\end{figure}

Il serait possible dans une optique d'avoir des modèles encore plus précis d'utiliser des voisinages de \textit{Moore} étendus, avec plusieurs rayons de voisins. Cependant par souci de simplicité nous nous sommes restreints à un rayon.

% \subsection{Représentation d'un forêt}

% Afin de représenter une forêt avec un automate cellulaire, nous avons défini une liste d'états que les cellules pouvaient prendre.

% \definition{Les états possibles sont :
% \begin{itemize}
%     \item Arbres
%     \item Arbres denses
%     \item Champs
%     \item Feu
%     \item Case brûlée\textsuperscript{*}
%     \item Eau\textsuperscript{*}
% \end{itemize}
% A noter que les cases $(*)$ ne peuvent brûler.}

% Nous avons choisi de travailler avec une matrice de taille $256 \times 256$ pour des raisons techniques : au-delà le temps de calcul devenait trop long, et l'ajout de lignes/colonnes ne représentait pas un intérêt suffisant au regard du temps de calcul que cela impliquait.

\section{Modèle d'Alexandridis}

Dans un premier temps, il est possible de réaliser une modélisation simple des feux de forêt en associant à chaque cellule une probabilité fixe de s'enflammer si l'un de ses voisins est en feu. Une telle tentative a donné des résultats mitigés. C'est pourquoi l'objectif de cette deuxième partie est de présenter un modèle plus avancé de modélisation des feux de forêts, appelé modèle d'\textit{Alexandridis}.

\subsection{Présentation du modèle}

Le modèle d'\textit{Alexandridis} prend en compte divers phénomènes pour simuler la propagation des incendies. Par la suite, nous avons choisi de nous concentrer sur la densité de végétation, le type de végétation ainsi que le vent dans la zone. Le modèle original prend également en considération l'élévation du terrain.

\proposition{On utilise les règles de transition suivantes, pour $(i,j) \in \mathbb{N}^2$, $t \in \mathbb{N}$ :
\begin{itemize}
    \item Si $m_{i,j} (t) = $ \mintinline{latex}{feu} alors $m_{i,j} (t+1) = $ \mintinline{latex}{brulé}
    \item Si $m_{i,j} (t) = $ \mintinline{latex}{feu} alors $m_{i \pm 1,j \pm 1} (t+1) = $ \mintinline{latex}{feu} avec une probabilité $p_b$
    \item Si $m_{i,j} (t) = $ \mintinline{latex}{brulé} alors $m_{i,j} (t+1) = $ \mintinline{latex}{brulé}
\end{itemize}}

\proposition{La probabilité $p_b$ qu'une cellule brûle est définie par
$p_b = p_h (1 + p_{veg}) (1 + p_{den}) p_{vent}$ avec $p_h = 0.27$ une constante, et $p_{veg}$ et $p_{den}$ des coefficients relatifs au type de cellule.
}

\begin{figure}[!ht]
    \centering
    \renewcommand{\arraystretch}{2}
    \setlength{\extrarowheight}{-3pt}
    \begin{tabular}{ |>{\centering\arraybackslash}p{4cm}|>{\centering\arraybackslash}p{2cm}|>{\centering\arraybackslash}p{2cm}| }
        \cline{2-3}
        \multicolumn{1}{c|}{} & $p_{veg}$ & $p_{den}$ \\
        \hline 
        Arbres & $0.3$ & $0.3$ \\ 
        \hline
        Arbres denses & $0.3$ & $0$ \\ 
        \hline
        Champs & $-0.1$ & $0$ \\
        \hline 
    \end{tabular}
    \caption{Probabilités $p_{veg}$ et $p_{den}$ selon le type de végétation}
\end{figure}

\proposition{La probabilité $p_{vent}$ liée au vent est définie par
\\ $p_{vent} = \exp (0.045 v) \times \exp (0.131 v \times (\cos (\theta) - 1))$ avec $\theta$ l'angle entre la propagation du feu et la direction du vent, et $v$ la vitesse du vent (en $m/s$)
}

\begin{figure}[!ht]
    \centering
    \begin{tikzpicture}[> = stealth]
        \coordinate (a) at (1,4);
        \coordinate (b) at (2,5);
        \coordinate (c) at (5,4);
        \coordinate (d) at (6,4);
        \coordinate (e) at (9,5);
        \coordinate (f) at (10,4);
        
        \draw pic[draw,fill=green!30,angle radius=1cm,"$\theta_1$" shift={(6mm,1mm)}] {angle=c--a--b};
        \draw pic[draw,fill=green!30,angle radius=2cm,"$\theta_2$" shift={(6mm,1mm)}] {angle=f--d--e};
        
        \draw[ultra thick,red, ->]  (a) -- node[above left] {\normalsize Vent} (b);
        \draw[ultra thick,blue,->]  (a) -- node[below] {\normalsize Propagation du feu} (c);

        \draw[ultra thick,red, ->]  (d) -- node[above left] {\normalsize Vent} (e);
        \draw[ultra thick,blue,->]  (d) -- node[below] {\normalsize Propagation du feu} (f);
    \end{tikzpicture}
    \caption{Configurations de vent}
\end{figure}

On a $\theta_1 > \theta_2$ et une vitesse plus élevée dans la seconde situation, ainsi la probabilité $p_{vent}$ sera plus élevée dans la seconde situation.

\subsection{Résultats}

Voici un résultat de modélisation de feu, avec un vent de $15 m/s$ orienté vers l'est :

\begin{figure}[!ht]
    \centering
    \begin{minipage}{0.50\textwidth}
      \centering
      \includegraphics[width=.6\linewidth]{pictures/model2/land_200_wind_notdense.png}
      \caption{Simulation Alexandridis}\label{Fig:Data3}
    \end{minipage}\hfil
 \end{figure}

\section{Hashlife}

Afin de réaliser des modélisations plus conséquentes (notamment en augmentant la taille de la grille), il faut trouver une manière de réduire le nombre de calculs. C'est l'objectif de l'algorithme de mémoïsation \mintinline{latex}|Hashlife|, notamment utilisé dans le logiciel \mintinline{latex}|Golly|\footnote{https://golly.sourceforge.io/} pour les simulations du \textit{Jeu de la Vie} de \textit{Conway}.

\subsection{Principe de Hashlife}

Au lieu de calculer chaque cellule indépendamment, l'algorithme considère des groupements de cellules, dits \textit{macro-cellules}, de taille $2^n \times 2^n$, que l'on peut redécouper en 4 quadrants de taille $2^{n-1} \times 2^{n-1}$ (partie en bleu sur la figure).

On appelle \textit{résultat} la macro-cellule centrale de taille $2^{n-1} \times 2^{n-1}$ (partie en rouge sur la figure).

\begin{figure}[!ht]
    \centering
        \begin{tikzpicture}[> = stealth]
            \draw[step=0.25cm,color=gray] (-1,-1) grid (1,1);
            \draw[fill=blue,fill opacity=0.7,draw=black] (-1,-1) rectangle ++(1,1);
            \draw[fill=blue,fill opacity=0.5,draw=black] (-1,0) rectangle ++(1,1);
            \draw[fill=blue,fill opacity=0.7,draw=black] (0,0) rectangle ++(1,1);
            \draw[fill=blue,fill opacity=0.5,draw=black] (0,-1) rectangle ++(1,1);
            \draw[step=1cm,color=black] (-1,-1) grid (1,1);
            \draw[step=0.25cm,color=gray] (2,-1) grid (4,1);
            \draw[step=1cm,color=black] (2,-1) grid (4,1);
            \draw[fill=red,fill opacity=0.6,draw=black] (2.5,-0.5) rectangle ++(1,1);
        \end{tikzpicture}
    \caption{Une macro-cellule de taille $2^{3} \times 2^{3}$}
\end{figure}

Ce découpage en macro-cellules permet de calculer le résultat sans considérer aucune information extérieure à la macro-cellule pendant $2^{n-2}$ unités de temps. Ce calcul est effectué récursivement selon deux cas :

\begin{itemize}
    \item Cas de base ($n=2$) : Le résultat est composé de seulement 4 cellules. Dans ce cas, nous le calculons directement en appliquant les règles de notre automate cellulaire. \vspace{10px}

    \item Cas récursif ($n > 2$) : Nous avons 4 quadrants de taille $2^{n-1} \times 2^{n-1}$ pour lesquels nous calculons récursivement leur résultat (illustré en bleu). Ensuite, il est nécessaire de calculer les 5 macro-cellules de taille $2^{n-2} \times 2^{n-2}$ (en rouge) en tenant compte des macro-cellules de taille $2^{n-1} \times 2^{n-1}$ associées (exemple en vert).

    Enfin, après ces précalculs, les quatre macro-cellules de taille $2^{n-2}$ (en jaune) peuvent être calculées pour obtenir le résultat recherché.
\end{itemize}
 \vspace{10px}

\begin{figure}[!ht]
    \centering
        \begin{tikzpicture}[> = stealth]
            \draw[fill=none,draw=black] (-1,-1) rectangle ++(2,2);
            \draw[step=1cm,color=black] (-1,-1) grid (1,1);
            \draw[fill=blue,fill opacity=0.6,draw=black] (-0.75,-0.75) rectangle ++(0.5,0.5);
            \draw[fill=blue,fill opacity=0.6,draw=black] (0.25,-0.75) rectangle ++(0.5,0.5);
            \draw[fill=blue,fill opacity=0.6,draw=black] (-0.75,0.25) rectangle ++(0.5,0.5);
            \draw[fill=blue,fill opacity=0.6,draw=black] (0.25,0.25) rectangle ++(0.5,0.5);
            \draw[step=1cm,color=black] (2,-1) grid (4,1);
            \draw[fill=gray,fill opacity=0.6,draw=black] (2.25,-0.75) rectangle ++(0.5,0.5);
            \draw[fill=gray,fill opacity=0.6,draw=black] (3.25,-0.75) rectangle ++(0.5,0.5);
            \draw[fill=gray,fill opacity=0.6,draw=black] (2.25,0.25) rectangle ++(0.5,0.5);
            \draw[fill=gray,fill opacity=0.6,draw=black] (3.25,0.25) rectangle ++(0.5,0.5);
            \draw[fill=red,fill opacity=0.6,draw=black] (2.25,-0.25) rectangle ++(0.5,0.5);
            \draw[fill=red,fill opacity=0.6,draw=black] (2.75,-0.75) rectangle ++(0.5,0.5);
            \draw[fill=red,fill opacity=0.6,draw=black] (2.75,0.25) rectangle ++(0.5,0.5);
            \draw[fill=red,fill opacity=0.6,draw=black] (3.25,-0.25) rectangle ++(0.5,0.5);
            \draw[fill=red,fill opacity=0.6,draw=black] (2.75,-0.25) rectangle ++(0.5,0.5);
            \draw[step=1cm,color=black] (5,-1) grid (7,1);
            \draw[fill=green,fill opacity=0.6,draw=black] (5,-0.5) rectangle ++(1,1);
            \draw[fill=red,fill opacity=0.6,draw=black] (5.25,-0.25) rectangle ++(0.5,0.5);
            \draw[step=1cm,color=black] (8,-1) grid (10,1);
            \draw[fill=yellow,fill opacity=0.6,draw=black] (8.5,-0.5) rectangle ++(0.5,0.5);
            \draw[fill=yellow,fill opacity=0.6,draw=black] (9,-0.5) rectangle ++(0.5,0.5);
            \draw[fill=yellow,fill opacity=0.6,draw=black] (8.5,0.0) rectangle ++(0.5,0.5);
            \draw[fill=yellow,fill opacity=0.6,draw=black] (9,0.0) rectangle ++(0.5,0.5);
        \end{tikzpicture}
    \caption{Calcul dans le cas $n > 2$}
\end{figure}

Si, dans le cas $n=2$, le nombre d'opérations est similaire à celui de la simulation naïve, le cas $n>2$ permet une réelle économie de calcul.

\subsection{Mémoïsation}

Cependant, \mintinline{latex}|Hashlife| ne se contente pas de réduire le nombre de calculs par itération. L'algorithme tire parti du fait que les automates cellulaires présentent des répétitions de motifs durant leur exécution, notamment avec les \textit{gliders} dans le \textit{Jeu de la Vie} qui se déplacent jusqu'aux bordures (infinies) de la grille en répétant 4 fois les mêmes motifs :

\begin{figure}[!ht]
    \centering
        \begin{tikzpicture}[> = stealth]
            \draw[step=0.4cm,color=gray] (0,0) grid (2,2);
            \draw[fill=black,draw=black] (0.4,0.8) rectangle ++(0.4,0.4);
            \draw[fill=black,draw=black] (0.8,0.4) rectangle ++(0.4,0.4);
            \draw[fill=black,draw=black] (1.2,0.4) rectangle ++(0.4,1.2);
            \draw[step=2cm,color=black] (0,0) grid (2,2);
            \draw[step=0.4cm,color=gray] (3.2,0) grid (5.2,2);
            \draw[fill=none,draw=black] (3.2,0) rectangle ++(2,2);
            \draw[fill=black,draw=black] (3.6,1.2) rectangle ++(0.4,0.4);
            \draw[fill=black,draw=black] (3.6,0.4) rectangle ++(0.8,0.4);
            \draw[fill=black,draw=black] (4,0.8) rectangle ++(0.8,0.4);
            \draw[step=0.4cm,color=gray] (6.4,0) grid (8.4,2);
            \draw[fill=none,draw=black] (6.4,0) rectangle ++(2,2);
            \draw[fill=black,draw=black] (6.8,0.4) rectangle ++(1.2,0.4);
            \draw[fill=black,draw=black] (7.6,0.8) rectangle ++(0.4,0.4);
            \draw[fill=black,draw=black] (7.2,1.2) rectangle ++(0.4,0.4);
            \draw[step=0.4cm,color=gray] (9.6,0) grid (11.6,2);
            \draw[fill=none,draw=black] (9.6,0) rectangle ++(2,2);
            \draw[fill=black,draw=black] (10,0.8) rectangle ++(0.4,0.4);
            \draw[fill=black,draw=black] (10.4,0) rectangle ++(0.4,0.8);
            \draw[fill=black,draw=black] (10.8,0.4) rectangle ++(0.4,0.8);
            \draw[step=0.4cm,color=gray] (12.8,0) grid (14.8,2);
            \draw[fill=none,draw=black] (12.8,0) rectangle ++(2,2);
            \draw[fill=black,draw=black] (13.6,0.4) rectangle ++(0.4,0.4);
            \draw[fill=black,draw=black] (14,0) rectangle ++(0.4,0.4);
            \draw[fill=black,draw=black] (14.4,0) rectangle ++(0.4,1.2);
        \end{tikzpicture}
    \caption{Un \textit{glider} et sa périodicité}
\end{figure}

C'est pourquoi \mintinline{latex}|Hashlife| réalise également une mémoïsation des résultats de chaque quadrant à l'aide d'une table de hachage, d'où le nom de l'algorithme. Cela permet de réutiliser au maximum les calculs et d'éviter de recalculer les situations récurrentes.

Mais le nombre de configurations différentes pour une macro-cellule de taille $2^{n} \times 2^{n}$ étant majoré par $2^{4^{n}}$, il est nécessaire de mettre en place des techniques efficaces de mémoïsation pour ne pas saturer la mémoire.

Une technique est de ne considérer qu'une instance de chaque macro-cellule existante dans la grille, et de fonctionner avec un système de pointeurs. Cette technique permet aussi de hasher beaucoup plus facilement chaque grille afin de réduire au maximum la taille de chaque couple clé/valeur dans la table de hashage

\subsection{Complexité}

En raison du nombre de configurations, il est complexe d'avoir une complexité théorique. Empiriquement dans des cas non dégénérés on observe une complexité en temps logarithmique en la taille de la grille. Cependant la mise en place d'un bon \textit{garbage collector} pour réduire au maximum les utilisations de mémoire extrême viennent augmenter cette complexité pour les cas avec peu de répétitions.

Bien que \mintinline{latex}|Hashlife| réduise drastiquement le temps de calcul pour de grandes grilles et permette de s'affranchir de leurs bornes en exploitant les motifs répétitifs, il existe toujours des cas dégénérés où l'algorithme a une complexité similaire à celle de l'approche naïve si les motifs ne se répètent jamais\footnote{L'algorithme \mintinline{latex}|Quicklife| permet de résoudre ce problème}.

\section{Conclusion}

Les automates cellulaires permettent de simuler de nombreux systèmes à interactions, tels que les feux de forêt. Cependant, pour obtenir des simulations d'une taille convaincante (et dans un temps raisonnable), il est nécessaire d'implémenter des algorithmes plus avancés comme \mintinline{latex}|Hashlife|.

% \subsection{Pseudo code}

% Une implémentation en pseudo-code de \mintinline{latex}|Hashlife| est la suivante :

% \begin{figure}[!ht]
%     \begin{minipage}{0.90\textwidth}
%       \centering
% \begin{algorithm}[H]
% \SetKwFunction{Hashlife}{Hashlife}
% \SetKwData{hashtable}{hashtable}
% \SetKwData{cellule}{cellule}
% \SetKwData{n}{n}
% \SetKwData{nouvellecellule}{nouvelle\_cellule}
% \SetKwData{enfantun}{enfant1}
% \SetKwData{enfantdeux}{enfant2}
% \SetKwData{enfanttrois}{enfant3}
% \SetKwData{enfantquatre}{enfant4}
% \SetKwProg{Fn}{Fonction}{:}{}

% \DontPrintSemicolon % Suppress semicolons at the end of lines

% \caption{Hashlife}\label{alg:cap}
% \SetAlgoLined
% \Fn{\Hashlife{\cellule}}{
%     \If{\KwSty{hash}(\cellule) \KwSty{dans} \hashtable}{
%         \Return \hashtable[\KwSty{hash}(\cellule)]\;
%     }
%     \BlankLine
%     \nouvellecellule $\gets$ Cellule vide\;
%     \If{\cellule.\n = 2}{
%         \nouvellecellule $\gets$ Calcul du résultat $2 \times 2$\;
%     }
%     \Else{
%         \nouvellecellule.\enfantun $\gets$ \Hashlife{\cellule.\enfantun}\;
%         \nouvellecellule.\enfantdeux $\gets$ \Hashlife{\cellule.\enfantdeux}\;
%         \nouvellecellule.\enfanttrois $\gets$ \Hashlife{\cellule.\enfanttrois}\;
%         \nouvellecellule.\enfantquatre $\gets$ \Hashlife{\cellule.\enfantquatre}\;
%     }
%     \BlankLine
%     \hashtable[\KwSty{hash}(\cellule)] $\gets$ \nouvellecellule\;
%     \Return \nouvellecellule\;
% }
% \end{algorithm}
%     \end{minipage}
% \end{figure}

% \section{Bibliographie}

\end{document}